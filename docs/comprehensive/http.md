# Http

## 304 响应

如果客户端发送的是一个 **条件验证(Conditional Validation)请求**，Web 服务器可能会返回 HTTP/304 响应，表明客户端中所请求资源的缓存仍然是有效的，也就是说该资源从上次缓存到现在并没有被修改过。

在进行条件请求时，客户端会提供给服务器一个 `If-Modified-Since` 请求头，其值为服务器上次返回的 `Last-Modified` 响应头中的日期值，还会提供一个 `If-None-Match` 请求头，值为服务器上次返回的 `ETag` 响应头的值。

服务器会读取到这两个请求头中的值，判断出客户端缓存的资源是否是最新的。如果是的话，服务器就会返回 HTTP/304 Not Modified 响应，但没有响应体，客户端收到304响应后，就会从缓存中读取对应的资源；如果服务器认为客户端缓存的资源已经过期了，那么服务器就会返回 HTTP/200 OK 响应，响应体就是该资源当前最新的内容，客户端收到 200 响应后，就会用新的响应体覆盖掉旧的缓存资源。

## 浏览器缓存

- Pragma

  http1.0 字段，指定缓存机制。

- Cache-Control

  指定缓存机制，覆盖其它设置。

- Expires

  http1.0 字段，缓存的过期时间，给出的日期/时间后，被响应认为是过时。

  需和 Last-Modified 结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端。当缓存中数据失效或过期，才决定从服务器更新数据。

- Last-Modified

  在浏览器第一次请求某一个 URL 时，服务器端的返回状态会是 200，内容是你请求的资源，同时有一个 Last-Modified 的属性标记 (HttpReponse Header) 此文件在服务期端最后被修改的时间。

- Etag

  ETag为 “被请求变量的实体标记”，即服务器响应时给请求 URL 标记，并在 HTTP 响应头中将其传送到客户端。

`Cache-Control/Expires（强缓存）` 的优先级要高于 `Last-Modified/ETag（协商缓存）`，即当本地副本根据 Cache-Control/Expires 发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。

用户在按 F5 进行刷新的时候，会忽略 Cache-Control/Expires 的设置，会再次发送请求去服务器请求，而 Last-Modified/Etag 还是有效的，服务器会根据情况判断返回 304 还是 200；而当用户使用 Ctrl+F5 进行强制刷新的时候，所有的缓存机制都将失效，重新从服务器拉去资源。