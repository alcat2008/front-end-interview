# 设计模式（Design Patterns）

## 什么是设计模式

- 设计模式是我们每天编程遇到的问题的可重用解决方案
- 设计模式主要是为了解决对象的生成和整合问题
- 设计模式可以作为可应用于现实世界编程问题的模板

## 设计模式分类

根据实际应用中遇到的不同问题，设计模式分为三种类型。

### 创建型模式（Creational Patterns）

这类模式用于对象的生成和生命周期的管理。

创造模式可以决定生成哪些对象，提高了程序的灵活性。模式如下：

- 抽象工厂模式
- 生成器模式
- 工厂方法模式
- 单例模式
- 原型模式

### 结构型模式（Structural Patterns）

这类模式描述了向现有对象添加功能的不同方式简单地说，这个模式着重于解耦对象的接口实现模式如下：

- 适配器模式
- 桥接模式
- 组合模式
- 装饰者模式
- 外观模式
- 享元模式
- 代理模式

### 行为型模式（Behavioral Patterns）

这类模式描述了对象如何相互作用，模式如下：

- 责任链模式
- 命令模式
- 解释器模式
- 迭代器模式
- 中介者模式
- 备忘录模式
- 观察者模式
- 状态模式
- 策略模式
- 模板方法模式
- 访问者模式

## 抽象工厂模式（Abstract Factory pattern）

它就像一个工厂，但一切都被封装起来：

- 提供对象的方法
- 构建对象的工厂
- 最终的对象
- 最终对象包含使用策略模式的对象

策略模式只是使用组合的方式，换句话说，它的类字段实际上是对象本身。

### 应用场景

抽象工厂模式可以创建类簇类的对象，而不需要指定具体的类，这使得抽象工厂很灵活。

通过抽象工厂模式可以对任何类簇对象进行建模并通过统一的接口供外部对象使用。

抽象工厂唯一不好的地方是它可能变得非常复杂。

## 生成器模式（Builder pattern）

Builder 模式是一种用于创建由其他对象组合构成的对象的模式。创建部件的方法应该独立于主对象。另外，为了从业务方隐藏部件的创建细节，两者是相互独立的。

在使用生成器模式时，生成器知道所有的细节，且创建细节完全对其他相关类屏蔽。

## 工厂方法模式（Factory Method pattern）

根据定义，只要想一个方法返回公共超类的几个可能的类中的一个，就可以使用工厂模式。

### 应用场景

当不知道需要何种类型的对象时可以使用工厂方法模式。

但是，有一点需要注意，确保所有潜在的类都具有相同的子类层次结构，这意味着在继承路径上有相同的父类。

可以使用工厂模式来集中类别选择的代码。或是不希望用户知道每一个可能的子类时。

## 单例模式（Singleton pattern）

当想要避免实例化多个对象时使用单例模式。单例使得只能从类实例化一个对象。

## 原型模式（Prototype pattern）

当想要通过克隆或拷贝对象来生成对象时，这就是原型模式。

通过原型模式可以在运行时添加已知父类的子类实例。

当有许多类只在运行时需要使用时可以使用原型模式。原型模式的好处之一是减少了创建多个子类。

## 适配器模式（Adapter pattern）

适配器设计模式允许使用两个完全不兼容的接口一起工作，正如其名字一样，适配不同接口。

适配器模式允许使用任何现有接口适配为目标接口。

从另一个角度看任何类都可以协同工作只要适配器解决了所有类都必须实现相同接口的问题。

## 桥接模式（Bridge pattern）

官方定义是将抽象与其实现分离开来，因此两者可以独立变化。

该模式用于将抽象与其实现分开，以便两者都可以独立修改。该模式包含一个用于桥接抽象类和实现类的接口。通过桥接模式，两种类型都可以修改而不会相互影响。

## 组合模式（Composite pattern）

组合模式允许统一处理单个对象和对象组合，这是组合设计模式的典型定义。

组合模式可以表示为部分 - 整体的层次结构。该结构的组件又可以划分为更小的组件。

一个更合乎逻辑的定义是组合设计模式是用来结构化数据或单独表示整个对象的每个部分的互相操作。

## 装饰者模式（Decorator pattern）

动态的为一个对象附加额外的功能，装饰模式可以不通过继承来实现功能扩展。

这种模式属于结构设计模式类别，也被称为包装模式，装饰设计模式解决了在不改变对象现有结构的情况下添加附加功能的问题。

另外，该模式创建了一个装饰器类，它包装原始类并在运行时向对象添加新的行为或操作。

### 应用场景

当选择这种模式时，需要动态地向单个对象添加新的功能，并且而不会影响其他对象。

通过继承来实现功能扩展会产生大量的子类，并且有可能这些子类还不足以覆盖所有需要扩展的功能。

当无法查看类定义或无法继承时，需要选择装饰模式。

## 外观模式（Facade pattern）

为子系统中的一组接口提供统一接口。外观模式定义了一个更高层次的接口，使子系统更易于使用。

外观模式隐藏了子系统的实现复杂性，为我们提供了一个简洁的接口。该接口负责调用现有子系统的功能。

## 享元模式（Flyweight pattern）

当需要创建大量相似对象时需要使用享元模式，这里的大量是上万的量级而不是平时接触的上百。

享元模式通过共享对象的相似部分，避免重复创建，来达到减小内存的使用。

## 代理模式（Proxy pattern）

代理是一个将被用来限制访问另一个类的类。

这可能是出于安全的考虑，通过代理来决定需要代理的对象哪些方法是可用的。

## 责任链模式（Chain of responsibility pattern）

责任链模式有一组对象，期望它们之间能够解决问题，如果第一个对象无法解决它，则将数据传递给责任链中的下一个数据。

通过多个接收者对象来处理请求，避免将请求的发送者耦合到其接收者。将接收对象串联起来，传递请求直到被其中一个处理掉。

责任链模式为请求创建一系列接收者对象。 在这种模式下，通常每个接收器都包含对另一个接收器的引用。

如果一个接收者不能处理该请求，则它将请求传递给下一个接受者。

## 命令模式（Command pattern）

命令设计模式是一种行为设计模式，其对象用于表示和封装稍后调用某个方法所需的所有信息。该信息包括方法名称，拥有方法的对象和方法参数的值。

基本上，它允许你做的是存储代码清单，在稍后或多次执行，并且通常使用命令模式可以撤销命令。

当这些封装的对象调用 execute() 方法，业务方或程序会执行指定命令或一段代码。

然后，调用者对象在调用时会传递命令给命令接收者，命令接收者拥有实际想要执行的代码，一旦从调用者接收到命令就立马执行。

## 解释器模式（Interpreter pattern）

解释器模式很容易被忽略，并且网上很少有使用这种模式。

但是，如果与 JavaScript 反射技术结合使用，会变得非常有用。它用于将数据的一种表示转换为另一种表示。

## 迭代器模式（Iterator pattern）

迭代器模式提供一种统一的方式来访问不同类型的对象集合。

## 中介者模式（Mediator pattern）

用于处理相关对象之间的通信。所有通信由中介者完成，通信双方不需要了解对方的任何信息。

更严格的定义是，中介者模式允许通过封装不同对象之间相互作用和相互通信的方式来实现松耦合，并且中介者模式允许每个对象的行为彼此独立地变化。

## 备忘录模式（Memento pattern）

用于存储对象以前状态的模式，首先，备忘录模式需要一个备忘录对象用于存储对象的不同状态，不同的状态及一些字段拥有不同的值。

然后，用于从当前目标备忘录对象读写值的初始对象，创建新的备忘录对象并赋值给当前备忘录对象。

最后，内部是一个 ArrayList 对象用于持有之前所有的备忘录对象，该 ArrayList 对象同时用于存储和检索备忘录对象。

## 观察者模式（Observer pattern）

当另一个对象更改时需要其他对象接收更新。

观察者模式唯一的缺点是对象或发布者可能发送对观察者，订阅者无关紧要的更新。

## 状态模式（State pattern）

它允许对象在其内部状态改变时改变其行为，这样让对象看起来改变了它所属的类。

## 策略模式（Strategy pattern）

如果要定义一个类，该类将具有与列表中的所有其他行为相似的行为，可以使用策略模式。

策略模式可以防止其他类的变化影响到当前类。也可以向业务方隐藏复杂和敏感代码。

## 模板方法模式（Template method pattern）

用于创建一组执行类似方法的子类。

要实现它，需要创建一个抽象类，它将包含一个名为模板方法的方法。

## 访问者模式（Visitor pattern）

访问者模式允许将方法添加到不同类型的类中 - 但它们不必是不同的类型 - 只会让复杂度有所增加，并不会对类有太多修改。

这可以根据所使用的类制作完全不同的方法。

也可以说访问者模式可以为现有类创建外部类来进行扩展以避免对原有类做修改。

## 参考资料

- [你需要了解的23种JavaScript设计模式](https://mp.weixin.qq.com/s/Ov62U8kktVv7Jz0Ukhekkg)
